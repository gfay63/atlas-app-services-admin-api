/* tslint:disable */
/* eslint-disable */
/**
 * MongoDB Atlas App Services Admin API
 * The App Services Admin API lets you programmatically perform administrative tasks over HTTPS. This includes defining & configuring things like:  - App Deployment & Security - APIs & Endpoints - Authentication & User Management - Data Sources - Device Sync - Environments - Functions - Logs - Rules - Schemas - Static Hosting - Triggers - Usage & Billing Metrics - Values & Secrets  The Admin API is for application development, configuration, and deployment. To actually use the features you configure with the Admin API, client applications connect with a [Realm SDK](https://mongodb.com/docs/realm/) or over an HTTPS API specific to your App.  ## Project & Application IDs  **Note**: The terms _Project ID_ and _Group ID_ are interchangeable.  Atlas App Services Admin API endpoints frequently require you to include two parameters in the URL:  - Your Atlas _Project ID_ (also sometimes called a _Group ID_) - Your App Services _Application ID_  ### Project ID  You can find your Project ID from the MongoDB Atlas dashboard or with the MongoDB Atlas CLI.  ### Application ID  To find an Application ID, make a request to the [List Apps](#operation/adminListApplications) endpoint for your project. You\'ll need an `access_token` to make this request. To learn how to get one, see [Get an Admin API Session Access Token](#get-an-admin-api-session-access-token).  ```sh curl --request GET \\   --header \'Authorization: Bearer <access_token>\' \\   https://realm.mongodb.com/api/admin/v3.0/groups/{groupId}/apps ```  This will return a list of objects describing each App Services App in the provided project/group. For Admin API requests, your Application ID is the ObjectId value in the `_id` field, _not_ the `client_app_id`.  ```json [   {     \"_id\": \"5997529e46224c6e42gb6dd9\",     \"group_id\": \"57879f6cc4b32dbe440bb8c5\",     \"domain_id\": \"5886619e46124e4c42fb5dd8\",     \"client_app_id\": \"myapp-abcde\",     \"name\": \"myapp\",     \"location\": \"US-VA\",     \"deployment_model\": \"GLOBAL\",     \"last_used\": 1615153544,     \"last_modified\": 0,     \"product\": \"standard\",     \"environment\": \"\"   } ] ```  ## Get an Admin API Session Access Token  Every request to the App Services Admin API must include a valid, unexpired access token issued by the MongoDB Cloud API. You include this token in the `Authorization` header of each request using the bearer auth scheme.  You need a valid [MongoDB Atlas programmatic API key](https://docs.atlas.mongodb.com/configure-api-access) for MongoDB Atlas to get a token.  Once you have an API key pair, call the authentication endpoint:  ```shell curl --request POST \\   --header \'Content-Type: application/json\' \\   --header \'Accept: application/json\' \\   --data \'{\"username\": \"<Public API Key>\", \"apiKey\": \"<Private API Key>\"}\' \\   https://realm.mongodb.com/api/admin/v3.0/auth/providers/mongodb-cloud/login ```  If authentication succeeds, App Services returns an access token as part of the JSON response document:  ```json {   \"access_token\": \"<access_token>\",   \"refresh_token\": \"<refresh_token>\",   \"user_id\": \"<user_id>\",   \"device_id\": \"<device_id>\" } ```  The `access_token` represents a limited-time authorization to interact with the Admin API. To authenticate a request, include the token in a [Bearer token](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication) `Authorization` header.  ```http Authorization: Bearer <access_token> ```  ## Refresh an Admin API Session Access Token  Session access tokens expire 30 minutes after they are issued. When you login, the response also includes a `refresh_token` that you can use to get a new access token. This is useful because you only need to log in with credentials one time. After that you can use the refresh token to re-authenticate for as long as its valid.  Refresh tokens expire 60 days after being issued.  To refresh your authentication and get a new `access_token`, call the auth session endpoint with your `refresh_token` in the `Authorization` header:  ```shell curl --request POST \\   --header \'Authorization: Bearer <refresh_token>\' \\   https://realm.mongodb.com/api/admin/v3.0/auth/session ```  If the refresh token is valid, the response body includes a new `access_token` that\'s valid for the next 30 minutes:  ```json {   \"access_token\": \"<access_token>\" } ```
 *
 * The version of the OpenAPI document: 3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;
}

export class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;

    constructor(param: ConfigurationParameters = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public isJsonMime(mime: string): boolean {
        const jsonMime: RegExp = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}
